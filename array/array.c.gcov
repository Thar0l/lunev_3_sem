        -:    0:Source:array.c
        -:    0:Graph:array.gcno
        -:    0:Data:array.gcda
        -:    0:Runs:4
        -:    0:Programs:1
        -:    1:/*
        -:    2: * array.c
        -:    3: *
        -:    4: *  Created on: Feb 21, 2014
        -:    5: *      Author: thar0l
        -:    6: */
        -:    7:
        -:    8:#include "array.h"
        -:    9:
        -:   10:struct array
        -:   11:{
        -:   12:	int *items;
        -:   13:	int size;
        -:   14:};
        -:   15:
        -:   16:int arr_sort(struct array *arr, int index);
        -:   17:
        -:   18:
      118:   19:struct array *arr_create(int size)
        -:   20:{
      118:   21:	struct array *temp = NULL;
      118:   22:    if (size <= 0)
        -:   23:    {
        8:   24:    	errno = EINVAL;
        8:   25:        return NULL;
        -:   26:    }
      110:   27:    temp = malloc (sizeof(struct array));
      110:   28:    if (temp == NULL)
        -:   29:    {
    #####:   30:    	errno = ENOMEM;
    #####:   31:        return NULL;
        -:   32:    }
      110:   33:    temp->size = size;
      110:   34:    temp->items = calloc(size, sizeof(int));
      110:   35:    if (temp->items == NULL)
        -:   36:    {
      101:   37:    	free (temp);
      101:   38:    	errno = ENOMEM;
      101:   39:        return NULL;
        -:   40:    }
        9:   41:	errno = 0;
        9:   42:    return temp;
        -:   43:}
        -:   44:
        -:   45:
      118:   46:void arr_delete(struct array *arr)
        -:   47:{
      118:   48:	if (arr == NULL)
        -:   49:	{
      109:   50:    	errno = EBADR;
      109:   51:        return;
        -:   52:	}
        9:   53:    free(arr->items);
        9:   54:    free(arr);
        9:   55:	errno = 0;
        9:   56:	return;
        -:   57:}
        -:   58:
        -:   59:
       14:   60:int arr_resize(struct array *arr, int size)
        -:   61:{
       14:   62:	if (size <= 0)
        -:   63:	{
        4:   64:		errno = EINVAL;
        4:   65:		return -1;
        -:   66:	}
       10:   67:	int *temp = calloc(size,sizeof(int));
       10:   68:	if (temp == NULL)
        -:   69:	{
        2:   70:		errno = ENOMEM;
        2:   71:		return -1;
        -:   72:	}
        8:   73:	int min = arr->size;
        8:   74:	if (size < min)
        4:   75:		min = size;
        -:   76:	int i;
       52:   77:	for (i = 0; i < min; i++)
       44:   78:		temp[i] = arr->items[i];
        8:   79:    free(arr->items);
        8:   80:    arr->size = size;
        8:   81:    arr->items = calloc(size, sizeof(int));
        8:   82:	if (arr->items == NULL)
        -:   83:	{
    #####:   84:		return -1;
        -:   85:	}
        8:   86:	for (i = 0; i < min; i++) arr->items[i] = temp[i];
        8:   87:    free(temp);
        8:   88:    temp=NULL;
        8:   89:	arr_sort(arr,0);
        8:   90:	errno = 0;
        8:   91:	return size;
        -:   92:}
        -:   93:
       16:   94:int arr_getitem(struct array *arr, int index, int *value)
        -:   95:{
       16:   96:	*value = 0;
       16:   97:    if (arr == NULL)
        -:   98:    {
        4:   99:    	errno = EBADR;
        4:  100:    	return -1;
        -:  101:    }
       12:  102:    if (index < 0)
        -:  103:    {
        4:  104:    	errno = EADDRNOTAVAIL;
        4:  105:        return -1;
        -:  106:    }
        8:  107:    if (index >= (arr->size))
        -:  108:    {
        4:  109:    	errno = EADDRNOTAVAIL;
        4:  110:        return -1;
        -:  111:    }
        4:  112:    *value = arr->items[index];
        4:  113:	errno = 0;
        4:  114:    return index;
        -:  115:}
        -:  116:
      152:  117:int arr_setitem(struct array *arr, int index, int value)
        -:  118:{
      152:  119:    if (arr == NULL)
        -:  120:    {
        4:  121:    	errno = EBADR;
        4:  122:    	return -1;
        -:  123:    }
      148:  124:    if (index < 0)
        -:  125:    {
        4:  126:    	errno = EADDRNOTAVAIL;
        4:  127:        return -1;
        -:  128:    }
      144:  129:    if (index >= (arr->size))
        -:  130:    {
        4:  131:    	errno = EADDRNOTAVAIL;
        4:  132:        return -1;
        -:  133:    }
      140:  134:    arr->items[index] = value;
      140:  135:	errno = 0;
      140:  136:    return arr_sort(arr, index);
        -:  137:}
        -:  138:
      148:  139: int arr_sort(struct array *arr, int index)
        -:  140:{
      148:  141:	int newindex = index;
        -:  142:	int i,j;
     3912:  143:	for (i = 0; i < arr->size; i++)
    60168:  144:	for (j = i; j < arr->size; j++)
    56404:  145:		if (arr->items[j] < arr->items[i])
        -:  146:		{
     2776:  147:			int temp = arr->items[i];
     2776:  148:			arr->items[i] = arr->items[j];
     2776:  149:			arr->items[j] = temp;
     2776:  150:			if (i == newindex)
      141:  151:				newindex = j;
     2776:  152:			if (j == newindex)
      141:  153:				newindex = i;
        -:  154:		}
      148:  155:	return newindex;
        -:  156:}
        -:  157:
       24:  158:int arr_for_each (struct array *arr, int (*foo) (int item, void *data), void *data)
        -:  159:{
       24:  160:    if (arr == NULL)
        -:  161:    {
        4:  162:    	errno = EBADR;
        4:  163:    	return -1;
        -:  164:    }
        -:  165:
       20:  166:    int i = 0;
      244:  167:    for (i = 0; i < arr->size; i++)
        -:  168:    	{
      224:  169:    		arr->items[i] = (*foo) (arr->items[i], data);
        -:  170:    	}
       20:  171:	errno = 0;
       20:  172:	return 0;
        -:  173:}
